// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: pomodoro.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const attachTaskToPomodoro = `-- name: AttachTaskToPomodoro :one
UPDATE pomodoro_sessions
SET
    task_id = $3
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, task_id, start_time, end_time, duration, completed, created_at, status, work_duration, break_duration, pause_time, total_pause_duration, actual_work_duration, note
`

type AttachTaskToPomodoroParams struct {
	ID     int32       `json:"id"`
	UserID pgtype.Int4 `json:"user_id"`
	TaskID pgtype.Int4 `json:"task_id"`
}

func (q *Queries) AttachTaskToPomodoro(ctx context.Context, arg AttachTaskToPomodoroParams) (PomodoroSession, error) {
	row := q.db.QueryRow(ctx, attachTaskToPomodoro, arg.ID, arg.UserID, arg.TaskID)
	var i PomodoroSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Completed,
		&i.CreatedAt,
		&i.Status,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.PauseTime,
		&i.TotalPauseDuration,
		&i.ActualWorkDuration,
		&i.Note,
	)
	return i, err
}

const createPomodoroSession = `-- name: CreatePomodoroSession :one
INSERT INTO pomodoro_sessions (
    user_id,
    task_id,
    status,
    work_duration,
    break_duration,
    start_time,
    note,
    duration
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $4 /* Use work_duration for duration */
) RETURNING id, user_id, task_id, start_time, end_time, duration, completed, created_at, status, work_duration, break_duration, pause_time, total_pause_duration, actual_work_duration, note
`

type CreatePomodoroSessionParams struct {
	UserID        pgtype.Int4        `json:"user_id"`
	TaskID        pgtype.Int4        `json:"task_id"`
	Status        string             `json:"status"`
	WorkDuration  int32              `json:"work_duration"`
	BreakDuration int32              `json:"break_duration"`
	StartTime     pgtype.Timestamptz `json:"start_time"`
	Note          pgtype.Text        `json:"note"`
}

func (q *Queries) CreatePomodoroSession(ctx context.Context, arg CreatePomodoroSessionParams) (PomodoroSession, error) {
	row := q.db.QueryRow(ctx, createPomodoroSession,
		arg.UserID,
		arg.TaskID,
		arg.Status,
		arg.WorkDuration,
		arg.BreakDuration,
		arg.StartTime,
		arg.Note,
	)
	var i PomodoroSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Completed,
		&i.CreatedAt,
		&i.Status,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.PauseTime,
		&i.TotalPauseDuration,
		&i.ActualWorkDuration,
		&i.Note,
	)
	return i, err
}

const detachTaskFromPomodoro = `-- name: DetachTaskFromPomodoro :one
UPDATE pomodoro_sessions
SET
    task_id = NULL
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, task_id, start_time, end_time, duration, completed, created_at, status, work_duration, break_duration, pause_time, total_pause_duration, actual_work_duration, note
`

type DetachTaskFromPomodoroParams struct {
	ID     int32       `json:"id"`
	UserID pgtype.Int4 `json:"user_id"`
}

func (q *Queries) DetachTaskFromPomodoro(ctx context.Context, arg DetachTaskFromPomodoroParams) (PomodoroSession, error) {
	row := q.db.QueryRow(ctx, detachTaskFromPomodoro, arg.ID, arg.UserID)
	var i PomodoroSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Completed,
		&i.CreatedAt,
		&i.Status,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.PauseTime,
		&i.TotalPauseDuration,
		&i.ActualWorkDuration,
		&i.Note,
	)
	return i, err
}

const getActivePomodoroSession = `-- name: GetActivePomodoroSession :one
SELECT id, user_id, task_id, start_time, end_time, duration, completed, created_at, status, work_duration, break_duration, pause_time, total_pause_duration, actual_work_duration, note FROM pomodoro_sessions
WHERE user_id = $1 AND (status = 'active' OR status = 'paused')
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetActivePomodoroSession(ctx context.Context, userID pgtype.Int4) (PomodoroSession, error) {
	row := q.db.QueryRow(ctx, getActivePomodoroSession, userID)
	var i PomodoroSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Completed,
		&i.CreatedAt,
		&i.Status,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.PauseTime,
		&i.TotalPauseDuration,
		&i.ActualWorkDuration,
		&i.Note,
	)
	return i, err
}

const getPomodoroConfig = `-- name: GetPomodoroConfig :one
SELECT user_id, work_duration, break_duration, long_break_duration, long_break_interval, auto_start_breaks, auto_start_pomodoros, created_at, updated_at FROM pomodoro_config
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) GetPomodoroConfig(ctx context.Context, userID int32) (PomodoroConfig, error) {
	row := q.db.QueryRow(ctx, getPomodoroConfig, userID)
	var i PomodoroConfig
	err := row.Scan(
		&i.UserID,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.LongBreakDuration,
		&i.LongBreakInterval,
		&i.AutoStartBreaks,
		&i.AutoStartPomodoros,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPomodoroSession = `-- name: GetPomodoroSession :one
SELECT id, user_id, task_id, start_time, end_time, duration, completed, created_at, status, work_duration, break_duration, pause_time, total_pause_duration, actual_work_duration, note FROM pomodoro_sessions
WHERE id = $1 AND user_id = $2
LIMIT 1
`

type GetPomodoroSessionParams struct {
	ID     int32       `json:"id"`
	UserID pgtype.Int4 `json:"user_id"`
}

func (q *Queries) GetPomodoroSession(ctx context.Context, arg GetPomodoroSessionParams) (PomodoroSession, error) {
	row := q.db.QueryRow(ctx, getPomodoroSession, arg.ID, arg.UserID)
	var i PomodoroSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Completed,
		&i.CreatedAt,
		&i.Status,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.PauseTime,
		&i.TotalPauseDuration,
		&i.ActualWorkDuration,
		&i.Note,
	)
	return i, err
}

const getPomodoroStats = `-- name: GetPomodoroStats :one
SELECT
  COUNT(*) AS total_sessions,
  COUNT(CASE WHEN ps.status = 'completed' THEN 1 END) AS completed_sessions,
  COUNT(CASE WHEN ps.status = 'cancelled' THEN 1 END) AS cancelled_sessions,
  SUM(ps.work_duration) AS total_work_mins,
  SUM(ps.break_duration) AS total_break_mins,
  SUM(ps.work_duration) + SUM(ps.break_duration) AS total_duration_mins,
  AVG(ps.work_duration) AS avg_duration_mins,
  (
    SELECT DATE(sub_ps.start_time)
    FROM pomodoro_sessions sub_ps
    WHERE sub_ps.user_id = $1
      AND (sub_ps.task_id = $2 OR $2 IS NULL)
      AND (sub_ps.start_time >= $3 OR $3 IS NULL)
      AND (sub_ps.start_time <= $4 OR $4 IS NULL)
    GROUP BY DATE(sub_ps.start_time)
    ORDER BY COUNT(*) DESC
    LIMIT 1
  ) AS most_productive_day,
  (
    SELECT EXTRACT(HOUR FROM sub_ps.start_time)::int
    FROM pomodoro_sessions sub_ps
    WHERE sub_ps.user_id = $1
      AND (sub_ps.task_id = $2 OR $2 IS NULL)
      AND (sub_ps.start_time >= $3 OR $3 IS NULL)
      AND (sub_ps.start_time <= $4 OR $4 IS NULL)
    GROUP BY EXTRACT(HOUR FROM sub_ps.start_time)
    ORDER BY COUNT(*) DESC
    LIMIT 1
  ) AS most_productive_hour
FROM pomodoro_sessions ps
WHERE ps.user_id = $1
  AND (ps.task_id = $2 OR $2 IS NULL)
  AND (ps.start_time >= $3 OR $3 IS NULL)
  AND (ps.start_time <= $4 OR $4 IS NULL)
`

type GetPomodoroStatsParams struct {
	UserID      pgtype.Int4        `json:"user_id"`
	TaskID      pgtype.Int4        `json:"task_id"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	StartTime_2 pgtype.Timestamptz `json:"start_time_2"`
}

type GetPomodoroStatsRow struct {
	TotalSessions      int64       `json:"total_sessions"`
	CompletedSessions  int64       `json:"completed_sessions"`
	CancelledSessions  int64       `json:"cancelled_sessions"`
	TotalWorkMins      int64       `json:"total_work_mins"`
	TotalBreakMins     int64       `json:"total_break_mins"`
	TotalDurationMins  int32       `json:"total_duration_mins"`
	AvgDurationMins    float64     `json:"avg_duration_mins"`
	MostProductiveDay  pgtype.Date `json:"most_productive_day"`
	MostProductiveHour int32       `json:"most_productive_hour"`
}

func (q *Queries) GetPomodoroStats(ctx context.Context, arg GetPomodoroStatsParams) (GetPomodoroStatsRow, error) {
	row := q.db.QueryRow(ctx, getPomodoroStats,
		arg.UserID,
		arg.TaskID,
		arg.StartTime,
		arg.StartTime_2,
	)
	var i GetPomodoroStatsRow
	err := row.Scan(
		&i.TotalSessions,
		&i.CompletedSessions,
		&i.CancelledSessions,
		&i.TotalWorkMins,
		&i.TotalBreakMins,
		&i.TotalDurationMins,
		&i.AvgDurationMins,
		&i.MostProductiveDay,
		&i.MostProductiveHour,
	)
	return i, err
}

const listPomodoroSessions = `-- name: ListPomodoroSessions :many
SELECT id, user_id, task_id, start_time, end_time, duration, completed, created_at, status, work_duration, break_duration, pause_time, total_pause_duration, actual_work_duration, note FROM pomodoro_sessions
WHERE user_id = $1
  AND (task_id = $2 OR $2 IS NULL)
  AND (start_time >= $3 OR $3 IS NULL)
  AND (start_time <= $4 OR $4 IS NULL)
ORDER BY start_time DESC
LIMIT $5
`

type ListPomodoroSessionsParams struct {
	UserID      pgtype.Int4        `json:"user_id"`
	TaskID      pgtype.Int4        `json:"task_id"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	StartTime_2 pgtype.Timestamptz `json:"start_time_2"`
	Limit       int32              `json:"limit"`
}

func (q *Queries) ListPomodoroSessions(ctx context.Context, arg ListPomodoroSessionsParams) ([]PomodoroSession, error) {
	rows, err := q.db.Query(ctx, listPomodoroSessions,
		arg.UserID,
		arg.TaskID,
		arg.StartTime,
		arg.StartTime_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PomodoroSession{}
	for rows.Next() {
		var i PomodoroSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TaskID,
			&i.StartTime,
			&i.EndTime,
			&i.Duration,
			&i.Completed,
			&i.CreatedAt,
			&i.Status,
			&i.WorkDuration,
			&i.BreakDuration,
			&i.PauseTime,
			&i.TotalPauseDuration,
			&i.ActualWorkDuration,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pausePomodoroSession = `-- name: PausePomodoroSession :one
UPDATE pomodoro_sessions
SET
    status = $3,
    pause_time = $4
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, task_id, start_time, end_time, duration, completed, created_at, status, work_duration, break_duration, pause_time, total_pause_duration, actual_work_duration, note
`

type PausePomodoroSessionParams struct {
	ID        int32              `json:"id"`
	UserID    pgtype.Int4        `json:"user_id"`
	Status    string             `json:"status"`
	PauseTime pgtype.Timestamptz `json:"pause_time"`
}

func (q *Queries) PausePomodoroSession(ctx context.Context, arg PausePomodoroSessionParams) (PomodoroSession, error) {
	row := q.db.QueryRow(ctx, pausePomodoroSession,
		arg.ID,
		arg.UserID,
		arg.Status,
		arg.PauseTime,
	)
	var i PomodoroSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Completed,
		&i.CreatedAt,
		&i.Status,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.PauseTime,
		&i.TotalPauseDuration,
		&i.ActualWorkDuration,
		&i.Note,
	)
	return i, err
}

const resumePomodoroSession = `-- name: ResumePomodoroSession :one
UPDATE pomodoro_sessions
SET
    status = $3,
    pause_time = NULL,
    total_pause_duration = COALESCE(total_pause_duration, 0) + $4
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, task_id, start_time, end_time, duration, completed, created_at, status, work_duration, break_duration, pause_time, total_pause_duration, actual_work_duration, note
`

type ResumePomodoroSessionParams struct {
	ID                 int32       `json:"id"`
	UserID             pgtype.Int4 `json:"user_id"`
	Status             string      `json:"status"`
	TotalPauseDuration pgtype.Int4 `json:"total_pause_duration"`
}

func (q *Queries) ResumePomodoroSession(ctx context.Context, arg ResumePomodoroSessionParams) (PomodoroSession, error) {
	row := q.db.QueryRow(ctx, resumePomodoroSession,
		arg.ID,
		arg.UserID,
		arg.Status,
		arg.TotalPauseDuration,
	)
	var i PomodoroSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Completed,
		&i.CreatedAt,
		&i.Status,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.PauseTime,
		&i.TotalPauseDuration,
		&i.ActualWorkDuration,
		&i.Note,
	)
	return i, err
}

const stopPomodoroSession = `-- name: StopPomodoroSession :one
UPDATE pomodoro_sessions
SET
    status = $3,
    end_time = $4,
    actual_work_duration = CASE
        WHEN total_pause_duration IS NOT NULL THEN
            EXTRACT(EPOCH FROM ($4 - start_time)) - total_pause_duration
        ELSE
            EXTRACT(EPOCH FROM ($4 - start_time))
    END
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, task_id, start_time, end_time, duration, completed, created_at, status, work_duration, break_duration, pause_time, total_pause_duration, actual_work_duration, note
`

type StopPomodoroSessionParams struct {
	ID      int32              `json:"id"`
	UserID  pgtype.Int4        `json:"user_id"`
	Status  string             `json:"status"`
	EndTime pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) StopPomodoroSession(ctx context.Context, arg StopPomodoroSessionParams) (PomodoroSession, error) {
	row := q.db.QueryRow(ctx, stopPomodoroSession,
		arg.ID,
		arg.UserID,
		arg.Status,
		arg.EndTime,
	)
	var i PomodoroSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TaskID,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Completed,
		&i.CreatedAt,
		&i.Status,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.PauseTime,
		&i.TotalPauseDuration,
		&i.ActualWorkDuration,
		&i.Note,
	)
	return i, err
}

const upsertPomodoroConfig = `-- name: UpsertPomodoroConfig :one
INSERT INTO pomodoro_config (
    user_id,
    work_duration,
    break_duration,
    long_break_duration,
    long_break_interval,
    auto_start_breaks,
    auto_start_pomodoros
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (user_id)
DO UPDATE SET
    work_duration = $2,
    break_duration = $3,
    long_break_duration = $4,
    long_break_interval = $5,
    auto_start_breaks = $6,
    auto_start_pomodoros = $7,
    updated_at = NOW()
RETURNING user_id, work_duration, break_duration, long_break_duration, long_break_interval, auto_start_breaks, auto_start_pomodoros, created_at, updated_at
`

type UpsertPomodoroConfigParams struct {
	UserID             int32 `json:"user_id"`
	WorkDuration       int32 `json:"work_duration"`
	BreakDuration      int32 `json:"break_duration"`
	LongBreakDuration  int32 `json:"long_break_duration"`
	LongBreakInterval  int32 `json:"long_break_interval"`
	AutoStartBreaks    bool  `json:"auto_start_breaks"`
	AutoStartPomodoros bool  `json:"auto_start_pomodoros"`
}

func (q *Queries) UpsertPomodoroConfig(ctx context.Context, arg UpsertPomodoroConfigParams) (PomodoroConfig, error) {
	row := q.db.QueryRow(ctx, upsertPomodoroConfig,
		arg.UserID,
		arg.WorkDuration,
		arg.BreakDuration,
		arg.LongBreakDuration,
		arg.LongBreakInterval,
		arg.AutoStartBreaks,
		arg.AutoStartPomodoros,
	)
	var i PomodoroConfig
	err := row.Scan(
		&i.UserID,
		&i.WorkDuration,
		&i.BreakDuration,
		&i.LongBreakDuration,
		&i.LongBreakInterval,
		&i.AutoStartBreaks,
		&i.AutoStartPomodoros,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
